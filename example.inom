// this line gets printed to the console log
// this __ gets printed __ :: line :: to the console log

** comment here from alien
$$ comment here from me

!*
 * block comment here
 * from alien
 *!
 
!$
 $ block comment here
 $ from me
 $!

$$ import modules by name
M module_x []
M module_y []
M module_z []

$$ define a module
[module_name Y module_a, module_b]

  $$ connect archors to arg vars
  G thing_name H module_a X node_a V anchor_1 C
  G stuff_name H module_b X node_a V anchor_1 C
  
  $$ define a node
  /node_name Y thing_name/
  
    $$ merge init properties with arg vars
    P prop_name: boolean H true R
    P prop_z: integer H 0 R
    P prop_x: integer H thing_name || 42 R
    
    $$ define an example process
    <
      $$ define a function
      (function_a Y arg_a, arg_b {
        K arg_a + arg_b N
      } integer)
      
      ** Reason:
      ** <question walk-walk-walk answer>
      !$
       $ S ... const
       $ I ... let
       $ U ... mut
       $!
      H zero: integer = prop_z IU
      H one: integer = 1 S
      H two: integer = 2 S
      H three: integer = add -> one, two S
      
      $$ pass values to the next node arg vars
      T anchor_name H add -> prop_x, three J
      
      ** demo
      // hello world
    >
  \anchor_name\
][

!*
 * define a main
 *!
inomauto module_main X node_main

$$ define a compact module
[module_a]
  $$ import nodes by name
  M node_a /\
  M node_b /\
][

$$ define a compact module
[module_b]
  $$ define a compact node
  /node_a/
    $$ import a process by name
    M proc_a <>
  \\
][

$$ export a process by name 
W proc_a <
  $$ empty
>

$$ export nodes by name
W node_a //
  $$ empty
\\

W node_b //
  $$ empty
\\

$$ define a module
[module_main]

  $$ define a node
  /node_main/
  
    $$ define a do while loop
    O I > -1 O
    
      $$ define an if-else statement
      F I == 50 E
        // __ is fifty ;; I
      L 
        // __ ;; I
      E
      
      $$ sleep for one second
      ... 1000
    Q++
  \\
][